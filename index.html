<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Minesweeper Field — Save/Load + Streaks</title>
<style>
  :root{
    --hud-bg: rgba(255,255,255,0.95);
    --hud-soft: rgba(255,255,255,0.90);
    --accent: #0b0b0b;
    --btn-size: 56px;
  }
  html,body{
    height:100%; margin:0; background:#87ceeb; overflow:hidden;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    -webkit-user-select:none; -webkit-touch-callout:none; user-select:none;
    -webkit-tap-highlight-color:transparent; -webkit-user-drag:none;
    touch-action:none;
  }
  canvas{ display:block; width:100%; height:100%; -webkit-user-select:none; touch-action:none; -webkit-tap-highlight-color:transparent; }

  .hud { position:absolute; inset:0; pointer-events:none; z-index:40; }
  .topbar { position:absolute; left:12px; top:12px; pointer-events:auto; display:flex; gap:8px; align-items:center; }
  .lockHint { background:var(--hud-bg); padding:8px 12px; border-radius:10px; font-weight:700; color:var(--accent); box-shadow:0 6px 18px rgba(0,0,0,0.08); }
  .gear { width:44px; height:44px; border-radius:10px; display:inline-grid; place-items:center; background:var(--hud-bg); cursor:pointer; box-shadow:0 8px 20px rgba(0,0,0,0.08); pointer-events:auto; -webkit-user-select:none; }

  .crosshair { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:28px; height:28px; pointer-events:none; }
  .crosshair:before,.crosshair:after{ content:""; position:absolute; left:50%; top:50%; width:2px; height:14px; background:var(--hud-bg); transform:translate(-50%,-50%); border-radius:2px; }
  .crosshair:after{ transform:translate(-50%,-50%) rotate(90deg); }

  .left-joystick {
    position:absolute; left:14px; bottom:14px; width:160px; height:160px;
    pointer-events:auto; border-radius:50%; background:rgba(0,0,0,0.10); display:flex; align-items:center; justify-content:center;
    touch-action:none; z-index:80; box-shadow:0 10px 30px rgba(0,0,0,0.12);
  }
  .joy-knob { width:76px; height:76px; border-radius:50%; background:var(--hud-bg); display:flex; align-items:center; justify-content:center; transform:translate(-50%,-50%); position:relative; left:50%; top:50%; box-shadow:0 10px 30px rgba(0,0,0,0.18); -webkit-user-select:none; }
  .joy-dot { width:12px; height:12px; border-radius:50%; background:var(--accent); opacity:0.95; }

  .controls { position:absolute; right:12px; bottom:12px; display:flex; flex-direction:column; gap:10px; pointer-events:auto; align-items:flex-end; z-index:80; }
  .btn { display:inline-flex; align-items:center; justify-content:center; min-width:var(--btn-size); height:var(--btn-size); background:var(--hud-bg); border-radius:12px; font-weight:800; color:var(--accent); box-shadow:0 8px 20px rgba(0,0,0,0.08); user-select:none; touch-action:none; pointer-events:auto; cursor:pointer; }
  .btn.small { min-width:48px; height:48px; border-radius:10px; font-size:14px; }

  .settings { position:absolute; right:12px; top:12px; background:var(--hud-bg); padding:12px; border-radius:12px; box-shadow:0 12px 30px rgba(0,0,0,0.10); pointer-events:auto; z-index:90; display:none; width:260px; }
  .settings.show{ display:block; }
  .settings label{ display:block; font-weight:700; color:var(--accent); margin-bottom:6px; }
  .settings input[type="range"]{ width:100%; }
  .settings .num-row { display:flex; gap:8px; align-items:center; }
  .settings .stepper { display:inline-flex; align-items:center; justify-content:center; width:40px; height:40px; border-radius:8px; background:#efefef; cursor:pointer; user-select:none; font-weight:800; }
  .settings input[type="number"]{ width:88px; padding:8px; border-radius:8px; border:1px solid #ddd; font-size:16px; text-align:center; -webkit-appearance: none; appearance:none; }

  .info { position:absolute; left:12px; bottom:12px; background:var(--hud-soft); padding:8px 10px; border-radius:10px; color:var(--accent); font-weight:700; pointer-events:none; box-shadow:0 6px 16px rgba(0,0,0,0.06); z-index:80; }

  .overlay { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); background:rgba(255,255,255,0.97); padding:18px 20px; border-radius:12px; display:none; pointer-events:auto; text-align:center; box-shadow:0 12px 34px rgba(0,0,0,0.12); z-index:100; }
  .overlay.show{ display:block; }
  .overlay h2{ margin:0 0 8px 0; color:var(--accent) }
  .overlay button{ margin-top:8px; padding:10px 14px; font-weight:800; border-radius:10px; border:0; background:#111;color:#fff; cursor:pointer; }

  .no-look { pointer-events:auto; }

  @media (min-width:900px){ .left-joystick{ display:none; } }
</style>
</head>
<body>
<div id="container"></div>

<div class="hud">
  <div class="topbar">
    <div id="lockHint" class="lockHint no-look">Click to enable mouse look</div>
    <div id="gear" class="gear no-look" title="Settings">⚙️</div>
  </div>

  <div class="crosshair" aria-hidden="true"></div>

  <div id="joy" class="left-joystick no-look" aria-hidden="false">
    <div id="joyKnob" class="joy-knob"><div class="joy-dot"></div></div>
  </div>

  <div id="controls" class="controls no-look">
    <div style="display:flex;gap:10px">
      <div id="jumpBtn" class="btn small no-look">Jump</div>
      <div id="restartBtn" class="btn no-look">Restart</div>
    </div>
  </div>

  <div id="settingsPanel" class="settings no-look" aria-hidden="true">
    <label for="fovRange">FOV: <span id="fovValue">70</span>°</label>
    <input id="fovRange" type="range" min="50" max="110" step="1" value="70" />
    <div style="height:12px"></div>
    <label>Grid Size</label>
    <div class="num-row">
      <div class="stepper no-look" id="gridWDec">−</div>
      <input id="gridW" type="number" inputmode="numeric" pattern="[0-9]*" value="10" min="6" max="40" />
      <div class="stepper no-look" id="gridWInc">+</div>
      <div style="width:12px"></div>
      <div class="stepper no-look" id="gridHDec">−</div>
      <input id="gridH" type="number" inputmode="numeric" pattern="[0-9]*" value="10" min="6" max="40" />
      <div class="stepper no-look" id="gridHInc">+</div>
    </div>
    <div style="height:12px"></div>
    <label>Mines</label>
    <div style="display:flex;gap:8px;align-items:center;">
      <div class="stepper no-look" id="minesDec">−</div>
      <input id="minesInput" type="number" inputmode="numeric" pattern="[0-9]*" value="15" min="1" max="400" />
      <div class="stepper no-look" id="minesInc">+</div>
    </div>
    <div style="height:12px"></div>

    <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
      <div id="applyBtn" class="btn no-look" style="padding:8px 12px; min-width:72px;">Apply</div>
      <div style="width:8px"></div>
      <div id="saveBtn" class="btn no-look" style="padding:8px 10px; min-width:72px;">Save</div>
      <div id="loadBtn" class="btn no-look" style="padding:8px 10px; min-width:72px;">Load</div>
      <div id="clearBtn" class="btn no-look" style="padding:8px 10px; min-width:72px;">Clear</div>
    </div>

    <div style="height:8px"></div>
    <div style="display:flex;gap:8px;align-items:center;">
      <div id="exportBtn" class="stepper no-look" style="width:auto;padding:8px 10px;">Export</div>
      <div id="importBtn" class="stepper no-look" style="width:auto;padding:8px 10px;">Import</div>
    </div>
    <div style="height:6px"></div>
    <div style="font-size:12px;color:#444;margin-top:6px">Export copies JSON to clipboard; Import asks for JSON to paste.</div>
  </div>

  <div class="info" id="info">Tiles uncovered: <span id="uncovered">0</span> / <span id="total">0</span> • Streak: <span id="streak">0</span></div>

  <div class="overlay" id="overlay">
    <h2 id="overlayTitle">Game Over</h2>
    <div id="overlayMsg">You stepped on a mine.</div>
    <button id="overlayRestart">Restart</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
/*
  Adds:
  - save/load/export/import via localStorage for "continue on GitHub Pages"
  - streaks (increment on win; reset on death or restart)
  - auto-save on key moments and periodic autosave
  - save structure is compact (grid size, minesPlaced, mine coords, uncovered coords, player pos/yaw/pitch, streak)
*/

// LOCALSTORAGE KEY
const SAVE_KEY = 'minesweeper_save_v1';

// ----------------- existing game code (minefield reskin + nerfed bob + joystick + touch look) -----------------
(() => {
  // selection/suggestion guard
  document.addEventListener('selectionchange', () => {
    const s = document.getSelection();
    if (s && s.type === 'Range') s.removeAllRanges();
    try { if (lookActive) { lookActive=false; lastPoint=null; } if (joyActive) endJoy(); } catch(e){}
  });
  window.addEventListener('contextmenu', (e) => e.preventDefault(), { passive:false });

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x87ceeb, 0.0009);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.getElementById('container').appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0,1.6,6);
  scene.add(new THREE.HemisphereLight(0xffffff, 0x444466, 0.95));
  const sun = new THREE.DirectionalLight(0xffffff, 0.6); sun.position.set(100,200,100); scene.add(sun);

  // params
  let GRID_W = 10, GRID_H = 10, MINES = 15;
  const BLOCK = 1;

  // storage
  const tiles = new Map();
  const tileGroup = new THREE.Group(); scene.add(tileGroup);

  // minefield materials
  const coveredSide = new THREE.MeshStandardMaterial({ color: 0x5a4f3f });
  const coveredTop = new THREE.MeshStandardMaterial({ color: 0x2d7a2f });
  const uncoveredSide = new THREE.MeshStandardMaterial({ color: 0x8f5a2b });
  const uncoveredTopPlain = new THREE.MeshStandardMaterial({ color: 0xdeb887 });
  const mineMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.6, roughness: 0.4 });
  const scorchMat = new THREE.MeshStandardMaterial({ color: 0x2b2216, transparent:true, opacity:0.85 });
  const boxGeom = new THREE.BoxGeometry(BLOCK, BLOCK, BLOCK);

  function k(x,z){ return `${x},${z}`; }
  function coveredMaterialArray(){ return [coveredSide, coveredSide, coveredTop, coveredSide, coveredSide, coveredSide]; }
  function uncoveredMaterialArray(topMat){ return [uncoveredSide, uncoveredSide, topMat || uncoveredTopPlain, uncoveredSide, uncoveredSide, uncoveredSide]; }

  let floor;
  function createFloor(){
    if (floor) scene.remove(floor);
    const fg = new THREE.PlaneGeometry(GRID_W * BLOCK * 4, GRID_H * BLOCK * 4);
    floor = new THREE.Mesh(fg, uncoveredSide);
    floor.rotation.x = -Math.PI/2;
    floor.position.y = -1.5;
    scene.add(floor);
  }

  // lazy mine placement so first uncovered is safe + 0
  let minesPlaced = false;

  function createTile(x,z){
    const mesh = new THREE.Mesh(boxGeom, coveredMaterialArray());
    mesh.position.set(x * BLOCK, BLOCK/2, z * BLOCK);
    mesh.userData.grid = {x,z};
    tileGroup.add(mesh);
    const t = { x,z, mine:false, uncovered:false, adj:0, mesh, topTexture: null, scorch:null };
    tiles.set(k(x,z), t);
    return t;
  }

  function shuffle(a){ for (let i=a.length-1;i>0;i--){ const r=Math.floor(Math.random()*(i+1)); [a[i],a[r]]=[a[r],a[i]]; } }

  function countAdjacent(x,z){
    let c=0;
    for (let dx=-1; dx<=1; dx++) for (let dz=-1; dz<=1; dz++){
      if (dx===0 && dz===0) continue;
      const t = tiles.get(k(x+dx, z+dz));
      if (t && t.mine) c++;
    }
    return c;
  }

  function placeMinesExcluding(cx, cz){
    const exclude = new Set();
    for (let dx=-1; dx<=1; dx++) for (let dz=-1; dz<=1; dz++) exclude.add(k(cx+dx, cz+dz));
    const candidates = Array.from(tiles.keys()).filter(key => !exclude.has(key));
    shuffle(candidates);
    for (let i = 0; i < Math.min(MINES, candidates.length); i++){
      const [tx,tz] = candidates[i].split(',').map(Number);
      const t = tiles.get(k(tx,tz));
      if (t) t.mine = true;
    }
    tiles.forEach(t => t.adj = countAdjacent(t.x, t.z));
    minesPlaced = true;
  }

  function buildGrid(){
    tiles.forEach(t => { tileGroup.remove(t.mesh); if (t.topTexture && t.topTexture.tex) t.topTexture.tex.dispose && t.topTexture.tex.dispose(); if (t.scorch) scene.remove(t.scorch); });
    tiles.clear();
    minesPlaced = false;
    const startX = -Math.floor(GRID_W/2);
    const startZ = -Math.floor(GRID_H/2);
    for (let i=0;i<GRID_W;i++) for (let j=0;j<GRID_H;j++) createTile(startX + i, startZ + j);
    createFloor();
    uncoveredCount = 0;
    document.getElementById('total').textContent = GRID_W*GRID_H - MINES;
    document.getElementById('uncovered').textContent = uncoveredCount;
  }

  function numberTopMaterial(n){
    const size = 256;
    const cvs = document.createElement('canvas'); cvs.width = cvs.height = size;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle = '#DEB887'; ctx.fillRect(0,0,size,size);
    ctx.strokeStyle = '#CDBA86'; ctx.lineWidth = 6; ctx.strokeRect(6,6,size-12,size-12);
    const colors = {1:'#0000ff',2:'#006400',3:'#cc0000',4:'#000080',5:'#800000',6:'#008080',7:'#000000',8:'#808080'};
    ctx.fillStyle = colors[n] || '#000'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = 'bold 140px sans-serif';
    ctx.fillText(String(n), size/2, size/2 + 8);
    const tex = new THREE.CanvasTexture(cvs); tex.flipY = false; tex.needsUpdate = true;
    const mat = new THREE.MeshStandardMaterial({ map: tex });
    return { mat, tex };
  }

  // particles + scorch
  const particles = [];
  const particleGeom = new THREE.SphereGeometry(0.06, 8, 6);
  const particleMat = new THREE.MeshStandardMaterial({ color: 0xff8a33, emissive: 0xff5a00, metalness: 0.1, roughness: 0.6 });
  const scorchGeom = new THREE.CircleGeometry(0.6, 32);

  // -- state
  let uncoveredCount = 0;
  let running = true;

  // STREAK LOGIC
  let streak = 0;
  const streakEl = document.getElementById('streak');
  function setStreak(n){
    streak = Math.max(0, Math.floor(n || 0));
    streakEl.textContent = streak;
  }

  function saveState(){
    try {
      const save = {
        v:1,
        GRID_W, GRID_H, MINES,
        minesPlaced: !!minesPlaced,
        mines: [], // array of "x,z"
        uncovered: [],
        player: { x: player.pos.x, y: player.pos.y, z: player.pos.z, yaw: player.yaw, pitch: player.pitch },
        uncoveredCount,
        streak
      };
      if (minesPlaced){
        tiles.forEach(t => { if (t.mine) save.mines.push([t.x, t.z]); });
      }
      tiles.forEach(t => { if (t.uncovered) save.uncovered.push([t.x, t.z]); });
      localStorage.setItem(SAVE_KEY, JSON.stringify(save));
      // quick visual feedback to console
      console.log('Saved game (localStorage).');
    } catch (e){
      console.warn('Save failed:', e);
    }
  }

  function loadState(){
    try {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return false;
      const save = JSON.parse(raw);
      if (!save || !save.v) return false;
      // apply grid settings
      GRID_W = Number(save.GRID_W) || GRID_W;
      GRID_H = Number(save.GRID_H) || GRID_H;
      MINES = Number(save.MINES) || MINES;
      buildGrid();
      // place mines if provided
      if (save.mines && save.mines.length){
        // clear first
        tiles.forEach(t => t.mine = false);
        for (const m of save.mines){ const [mx,mz] = m; const t = tiles.get(k(mx,mz)); if (t) t.mine = true; }
        tiles.forEach(t => t.adj = countAdjacent(t.x, t.z));
        minesPlaced = true;
      } else {
        minesPlaced = !!save.minesPlaced;
        if (minesPlaced) tiles.forEach(t => t.adj = countAdjacent(t.x, t.z));
      }
      // apply uncovered
      uncoveredCount = 0;
      if (Array.isArray(save.uncovered)){
        for (const u of save.uncovered){
          const [ux,uz] = u;
          const t = tiles.get(k(ux,uz));
          if (!t) continue;
          t.uncovered = true;
          if (t.mine){
            t.mesh.material = uncoveredMaterialArray(mineMat);
          } else {
            if (t.adj > 0){ const { mat, tex } = numberTopMaterial(t.adj); t.topTexture = { mat, tex }; t.mesh.material = uncoveredMaterialArray(mat); }
            else t.mesh.material = uncoveredMaterialArray(uncoveredTopPlain);
          }
          uncoveredCount++;
        }
      }
      // apply player
      if (save.player){
        player.pos.set(save.player.x, save.player.y, save.player.z);
        player.yaw = save.player.yaw || 0;
        player.pitch = save.player.pitch || 0;
        camera.position.copy(player.pos);
      }
      // uncoveredCount and UI
      document.getElementById('uncovered').textContent = uncoveredCount;
      document.getElementById('total').textContent = GRID_W*GRID_H - MINES;
      // streak
      setStreak(save.streak || 0);
      console.log('Loaded save from localStorage.');
      return true;
    } catch (e){
      console.warn('Load failed:', e);
      return false;
    }
  }

  function clearSave(){
    try { localStorage.removeItem(SAVE_KEY); console.log('Save cleared'); } catch(e){}
  }

  // auto-save throttle: call saveState at key moments & periodic
  let saveTimer = null;
  function scheduleAutoSave(){
    if (saveTimer) return;
    saveTimer = setTimeout(()=>{ saveTimer = null; saveState(); }, 600);
  }
  // also periodic autosave every 8s (while running)
  setInterval(()=>{ if (running) saveState(); }, 8000);

  // export/import helpers
  async function exportSaveToClipboard(){
    const raw = localStorage.getItem(SAVE_KEY);
    if (!raw) { alert('No save to export.'); return; }
    try { await navigator.clipboard.writeText(raw); alert('Save JSON copied to clipboard.'); }
    catch (e){ prompt('Copy this JSON manually:', raw); }
  }
  function importSaveFromPrompt(){
    const txt = prompt('Paste save JSON here (exported from another device):');
    if (!txt) return;
    try {
      const obj = JSON.parse(txt);
      localStorage.setItem(SAVE_KEY, JSON.stringify(obj));
      alert('Imported save. Reloading state...');
      loadState();
    } catch (e){
      alert('Invalid JSON.');
    }
  }

  // explosion & uncover logic
  function explodeAtTile(tile){
    const center = new THREE.Vector3(tile.x * BLOCK, BLOCK/2, tile.z * BLOCK);
    // scorch
    const scorch = new THREE.Mesh(scorchGeom, scorchMat);
    scorch.rotation.x = -Math.PI/2;
    scorch.position.set(center.x, 0.51, center.z);
    scene.add(scorch);
    tile.scorch = scorch;
    // flash
    const flash = new THREE.PointLight(0xffaa66, 3, 6);
    flash.position.copy(center).setY(1.2);
    scene.add(flash);
    // spawn particles
    const count = 18;
    for (let i=0;i<count;i++){
      const m = new THREE.Mesh(particleGeom, particleMat.clone());
      const vx = (Math.random()*2 - 1) * 3;
      const vy = (Math.random()*1.5 + 1.2) * 2;
      const vz = (Math.random()*2 - 1) * 3;
      m.position.copy(center).setY(center.y + 0.4);
      m.scale.setScalar(1.0 * (0.6 + Math.random()*0.8));
      scene.add(m);
      particles.push({ mesh: m, vel: new THREE.Vector3(vx, vy, vz), life:0, maxLife: 0.9 + Math.random()*0.6, birth: performance.now(), light: null });
    }
    // flash object
    const flashObj = { light: flash, start: performance.now(), dur: 600 };
    particles.push(flashObj);
    tile.mesh.material = uncoveredMaterialArray(uncoveredTopPlain);
  }

  function revealAllMines(){
    tiles.forEach(t => { if (t.mine) t.mesh.material = uncoveredMaterialArray(mineMat); });
  }

  function checkWin(){
    if (uncoveredCount >= GRID_W*GRID_H - MINES){
      // increment streak, save, and show win
      setStreak(streak + 1);
      saveState();
      gameOver(true);
    }
  }

  function gameOver(win){
    running = false;
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayMsg = document.getElementById('overlayMsg');
    overlay.classList.add('show');
    overlayTitle.textContent = win ? 'You Win!' : 'You Lost';
    overlayMsg.textContent = win ? 'All safe tiles uncovered.' : 'You stepped on a mine.';
    if (!win){
      // reset streak on death
      setStreak(0);
      saveState();
    } else {
      saveState();
    }
  }

  function gameOverAfterExplosion(){
    revealAllMines();
    setTimeout(()=> gameOver(false), 700);
  }

  // uncover logic (lazy placement first uncover)
  function uncoverTile(x,z){
    if (!minesPlaced) placeMinesExcluding(x, z);
    const tile = tiles.get(k(x,z));
    if (!tile || tile.uncovered) return;
    tile.uncovered = true;
    if (tile.mine){
      explodeAtTile(tile);
      gameOverAfterExplosion();
      scheduleAutoSave();
      return;
    }
    if (tile.adj > 0){
      const { mat, tex } = numberTopMaterial(tile.adj);
      tile.topTexture = { mat, tex };
      tile.mesh.material = uncoveredMaterialArray(mat);
    } else {
      tile.mesh.material = uncoveredMaterialArray(uncoveredTopPlain);
    }
    uncoveredCount++;
    document.getElementById('uncovered').textContent = uncoveredCount;
    if (tile.adj === 0){
      for (let dx=-1; dx<=1; dx++) for (let dz=-1; dz<=1; dz++){
        if (dx===0 && dz===0) continue;
        const nt = tiles.get(k(x+dx, z+dz));
        if (nt && !nt.uncovered && !nt.mine) uncoverTile(nt.x, nt.z);
      }
    }
    checkWin();
    scheduleAutoSave();
  }

  // build initial grid
  buildGrid();

  // player + movement physics + nerfed bobbing
  const player = { pos: new THREE.Vector3(0,1.6,GRID_H/2 + 3), vel: new THREE.Vector3(), yaw: 0, pitch: 0, height: 1.6 };
  camera.position.copy(player.pos);
  const MOVE_SPEED = 3.6, MAX_SPEED = 5.5, JUMP_SPEED = 6.4, GRAV = -20.0;
  const keys = { forward:0, back:0, left:0, right:0 };
  let canJump = false;
  window.addEventListener('keydown', (e)=> {
    if (e.code === 'KeyW') keys.forward = 1;
    if (e.code === 'KeyS') keys.back = 1;
    if (e.code === 'KeyA') keys.left = 1;
    if (e.code === 'KeyD') keys.right = 1;
    if (e.code === 'Space') { if (canJump) { player.vel.y = JUMP_SPEED; canJump = false; } }
  });
  window.addEventListener('keyup', (e)=> {
    if (e.code === 'KeyW') keys.forward = 0;
    if (e.code === 'KeyS') keys.back = 0;
    if (e.code === 'KeyA') keys.left = 0;
    if (e.code === 'KeyD') keys.right = 0;
  });

  // joystick
  const joyEl = document.getElementById('joy'), joyKnob = document.getElementById('joyKnob');
  let joyActive = false, joyPointerId = null, joyCenter = null, joyVec = {x:0,y:0};
  function startJoy(coordX, coordY, id){ joyActive = true; joyPointerId = id || 'mouse'; const r = joyEl.getBoundingClientRect(); joyCenter = { x: r.left + r.width/2, y: r.top + r.height/2 }; updateJoy(coordX, coordY); }
  function updateJoy(cx, cy){ const dx = cx - joyCenter.x, dy = cy - joyCenter.y; const max = 56; const nx = Math.max(-1, Math.min(1, dx / max)); const ny = Math.max(-1, Math.min(1, dy / max)); joyVec.x = nx; joyVec.y = -ny; const px = nx * 50, py = -ny * 50; joyKnob.style.transform = `translate(calc(-50% + ${px}px), calc(-50% + ${py}px))`; }
  function endJoy(){ joyActive=false; joyPointerId=null; joyVec.x=0; joyVec.y=0; joyKnob.style.transform='translate(-50%,-50%)'; }

  joyEl.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); e.preventDefault(); startJoy(e.clientX,e.clientY,e.pointerId); joyEl.setPointerCapture && joyEl.setPointerCapture(e.pointerId); }, { passive:false });
  window.addEventListener('pointermove', (e)=>{ if (!joyActive) return; if (e.pointerId !== undefined && e.pointerId !== joyPointerId) return; updateJoy(e.clientX, e.clientY); }, { passive:false });
  window.addEventListener('pointerup', (e)=>{ if (!joyActive) return; if (e.pointerId !== undefined && e.pointerId !== joyPointerId) return; endJoy(); try{ joyEl.releasePointerCapture && joyEl.releasePointerCapture(e.pointerId); }catch{} }, { passive:false });
  joyEl.addEventListener('pointercancel', (e)=>{ if (e.pointerId === joyPointerId) endJoy(); }, { passive:false });

  joyEl.addEventListener('touchstart', (e)=>{ e.stopPropagation(); e.preventDefault(); const t=e.changedTouches[0]; startJoy(t.clientX,t.clientY,'t'+t.identifier); }, { passive:false });
  joyEl.addEventListener('touchmove', (e)=>{ if (!joyActive) return; const t=e.changedTouches[0]; updateJoy(t.clientX,t.clientY); }, { passive:false });
  joyEl.addEventListener('touchend', (e)=>{ endJoy(); }, { passive:false });
  joyEl.addEventListener('touchcancel', (e)=>{ endJoy(); }, { passive:false });

  joyEl.addEventListener('mousedown', (e)=>{ e.stopPropagation(); e.preventDefault(); startJoy(e.clientX,e.clientY, 'mouse'); });
  window.addEventListener('mousemove', (e)=>{ if (!joyActive) return; updateJoy(e.clientX, e.clientY); });
  window.addEventListener('mouseup', ()=>{ if (joyActive) endJoy(); });

  // look handling (global except UI)
  let lookActive = false, lookPointerId = null, lastPoint = null;
  function isPointerOnUI(x,y){ const el = document.elementFromPoint(x,y); if (!el) return false; return !!el.closest('.no-look'); }

  window.addEventListener('pointerdown', (e)=>{ if (isPointerOnUI(e.clientX,e.clientY)) return; if (joyActive && e.pointerId === joyPointerId) return; lookActive = true; lookPointerId = e.pointerId; lastPoint = { x: e.clientX, y: e.clientY }; try{ e.preventDefault(); }catch(_) {} }, { passive:false });

  window.addEventListener('pointermove', (e)=>{ if (!lookActive || e.pointerId !== lookPointerId) return; const dx = e.clientX - lastPoint.x, dy = e.clientY - lastPoint.y; player.yaw -= dx * 0.0032; player.pitch -= dy * 0.0032; player.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, player.pitch)); lastPoint = { x: e.clientX, y: e.clientY }; try{ e.preventDefault(); }catch(_) {} }, { passive:false });

  window.addEventListener('pointerup', (e)=>{ if (lookActive && e.pointerId === lookPointerId){ lookActive=false; lookPointerId=null; lastPoint=null; } }, { passive:false });
  window.addEventListener('pointercancel', (e)=>{ if (lookActive && e.pointerId === lookPointerId){ lookActive=false; lookPointerId=null; lastPoint=null; } }, { passive:false });

  // pointer lock desktop
  const canvas = renderer.domElement;
  document.getElementById('lockHint').addEventListener('pointerdown', (e)=>{ e.stopPropagation(); e.preventDefault(); if (document.pointerLockElement !== canvas) canvas.requestPointerLock?.(); }, { passive:false });
  document.addEventListener('pointerlockchange', ()=>{ const pl = (document.pointerLockElement === canvas); document.getElementById('lockHint').style.display = pl ? 'none' : 'block'; });
  document.addEventListener('mousemove', (e)=>{ if (document.pointerLockElement === canvas){ player.yaw -= (e.movementX || 0) * 0.0028; player.pitch -= (e.movementY || 0) * 0.0028; player.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, player.pitch)); } });

  // step-on uncover
  function tryUncoverUnderPlayer(){
    if (!running) return;
    const feetY = player.pos.y - player.height;
    if (feetY <= 0.05){
      const gx = Math.floor((player.pos.x + 0.5*BLOCK)/BLOCK);
      const gz = Math.floor((player.pos.z + 0.5*BLOCK)/BLOCK);
      const t = tiles.get(k(gx, gz));
      if (t && !t.uncovered) uncoverTile(gx, gz);
    }
  }

  // movement + physics + nerfed bobbing + particle update
  let bobTime = 0;
  function animateLoop(){
    requestAnimationFrame(animateLoop);
    const now = performance.now();
    const dt = Math.min(0.05, (now - (animateLoop._last || now))/1000);
    animateLoop._last = now;

    // desired movement
    const inputX = (keys.right - keys.left) + (joyVec.x || 0);
    const inputZ = (keys.forward - keys.back) + (joyVec.y || 0);
    let desired = new THREE.Vector3();
    if (Math.abs(inputX) > 0.001 || Math.abs(inputZ) > 0.001){
      const baseQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(player.pitch, player.yaw, 0, 'YXZ'));
      const forward = new THREE.Vector3(0,0,-1).applyQuaternion(baseQuat).setY(0).normalize();
      const right = new THREE.Vector3(1,0,0).applyQuaternion(baseQuat).setY(0).normalize();
      desired.addScaledVector(forward, inputZ);
      desired.addScaledVector(right, inputX);
      if (desired.lengthSq() > 1) desired.normalize();
      desired.multiplyScalar(MOVE_SPEED);
    }

    // acceleration
    const accel = 40.0;
    player.vel.x += (desired.x - player.vel.x) * Math.min(1, accel * dt);
    player.vel.z += (desired.z - player.vel.z) * Math.min(1, accel * dt);
    const horiz = Math.hypot(player.vel.x, player.vel.z);
    if (horiz > MAX_SPEED){ const s = MAX_SPEED / horiz; player.vel.x *= s; player.vel.z *= s; }

    player.vel.y += GRAV * dt;

    const next = player.pos.clone().addScaledVector(player.vel, dt);
    const feetY = next.y - player.height;
    if (feetY <= 0.01){ next.y = player.height; player.vel.y = 0; canJump = true; }

    player.pos.copy(next);

    // camera orientation
    const baseQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(player.pitch, player.yaw, 0, 'YXZ'));

    // NERFED BOBBING
    const groundSpeed = Math.hypot(player.vel.x, player.vel.z);
    if (groundSpeed > 0.05 && (player.pos.y - player.height) <= 0.02){ bobTime += dt * (1 + groundSpeed / MOVE_SPEED) * 4.0; } else { bobTime += dt * -2.0; if (bobTime < 0) bobTime = 0; }
    const bobAmp = Math.min(0.015, 0.002 + (groundSpeed / MAX_SPEED) * 0.012);
    const bobY = Math.sin(bobTime * 2.0) * bobAmp;
    const sway = Math.sin(bobTime * 1.2) * (bobAmp * 0.3);
    const roll = Math.sin(bobTime * 2.0) * (Math.min(0.006, (groundSpeed / MAX_SPEED) * 0.006));
    const rollQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), roll);
    const finalQ = baseQ.clone().multiply(rollQ);
    camera.quaternion.copy(finalQ);
    const rightVec = new THREE.Vector3(1,0,0).applyQuaternion(baseQ).setY(0).normalize();
    const bobOffset = new THREE.Vector3().addScaledVector(rightVec, sway);
    camera.position.set(player.pos.x + bobOffset.x, player.pos.y + bobY, player.pos.z + bobOffset.z);

    // update particles & flashes
    const nowMs = performance.now();
    for (let i = particles.length - 1; i >= 0; i--){
      const p = particles[i];
      if (p.light){
        const age = nowMs - p.start;
        const t = age / p.dur;
        if (t >= 1){ scene.remove(p.light); particles.splice(i,1); continue; }
        p.light.intensity = 3 * (1 - t);
        continue;
      }
      if (p.mesh){
        p.life += dt;
        p.vel.y += -6.0 * dt;
        p.mesh.position.addScaledVector(p.vel, dt);
        const frac = 1 - (p.life / p.maxLife);
        if (p.mesh.material.emissive) p.mesh.material.emissiveIntensity = Math.max(0.05, frac);
        p.mesh.scale.multiplyScalar(1 - dt * 0.6);
        if (p.life >= p.maxLife){
          scene.remove(p.mesh);
          if (p.mesh.geometry) p.mesh.geometry.dispose && p.mesh.geometry.dispose();
          if (p.mesh.material) p.mesh.material.dispose && p.mesh.material.dispose();
          particles.splice(i,1);
        }
      }
    }

    tryUncoverUnderPlayer();
    renderer.render(scene, camera);
  }
  requestAnimationFrame(animateLoop);

  // jump
  const jumpBtn = document.getElementById('jumpBtn');
  jumpBtn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); e.preventDefault(); if (canJump){ player.vel.y = JUMP_SPEED; canJump = false; } }, { passive:false });

  // settings + steppers + buttons + save/load/export/import wiring
  const gear = document.getElementById('gear'), settingsPanel = document.getElementById('settingsPanel');
  const fovRange = document.getElementById('fovRange'), fovValue = document.getElementById('fovValue');
  const gridWInput = document.getElementById('gridW'), gridHInput = document.getElementById('gridH'), minesInput = document.getElementById('minesInput');
  const applyBtn = document.getElementById('applyBtn');
  const saveBtn = document.getElementById('saveBtn'), loadBtn = document.getElementById('loadBtn'), clearBtn = document.getElementById('clearBtn');
  const exportBtn = document.getElementById('exportBtn'), importBtn = document.getElementById('importBtn');

  gear.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); e.preventDefault(); settingsPanel.classList.toggle('show'); }, { passive:false });
  settingsPanel.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });

  fovRange.addEventListener('input', (e)=>{ const v=Number(e.target.value); fovValue.textContent=v; camera.fov=v; camera.updateProjectionMatrix(); });

  applyBtn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); e.preventDefault(); const newW = Math.max(6, Math.min(40, Number(gridWInput.value) || GRID_W)); const newH = Math.max(6, Math.min(40, Number(gridHInput.value) || GRID_H)); const newM = Math.max(1, Math.min(newW*newH-1, Number(minesInput.value) || MINES)); GRID_W = newW; GRID_H = newH; MINES = newM; player.pos.set(0,1.6, GRID_H/2 + 3); camera.position.copy(player.pos); restartGame(); settingsPanel.classList.remove('show'); }, { passive:false });

  function setupStepper(decId, incId, inputEl, min, max){
    document.getElementById(decId).addEventListener('pointerdown', (e)=>{ e.stopPropagation(); e.preventDefault(); inputEl.value = Math.max(min, Number(inputEl.value) - 1); }, { passive:false});
    document.getElementById(incId).addEventListener('pointerdown', (e)=>{ e.stopPropagation(); e.preventDefault(); inputEl.value = Math.min(max, Number(inputEl.value) + 1); }, { passive:false});
    inputEl.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); });
  }
  setupStepper('gridWDec','gridWInc', gridWInput, 6, 40);
  setupStepper('gridHDec','gridHInc', gridHInput, 6, 40);
  setupStepper('minesDec','minesInc', minesInput, 1, 400);

  // Save / Load / Clear
  saveBtn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); e.preventDefault(); saveState(); alert('Saved progress to localStorage.'); }, { passive:false });
  loadBtn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); e.preventDefault(); const ok = loadState(); if (!ok) alert('No save found.'); else alert('Loaded save.'); }, { passive:false });
  clearBtn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); e.preventDefault(); clearSave(); alert('Save cleared from localStorage.'); setStreak(0); }, { passive:false });

  exportBtn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); e.preventDefault(); exportSaveToClipboard(); }, { passive:false });
  importBtn.addEventListener('pointerdown', (e)=>{ e.stopPropagation(); e.preventDefault(); importSaveFromPrompt(); }, { passive:false });

  // overlay restart
  document.getElementById('overlayRestart').addEventListener('pointerdown', (e)=>{ e.stopPropagation(); e.preventDefault(); restartGame(); }, { passive:false });

  // restart logic: reset streak on manual restart (user requested)
  function restartGame(){
    tiles.forEach(t => { if (t.topTexture && t.topTexture.tex) t.topTexture.tex.dispose && t.topTexture.tex.dispose(); if (t.scorch) scene.remove(t.scorch); });
    particles.forEach(p => { if (p.mesh) { scene.remove(p.mesh); p.mesh.geometry.dispose && p.mesh.geometry.dispose(); p.mesh.material.dispose && p.mesh.material.dispose(); } if (p.light) scene.remove(p.light); });
    particles.length = 0;
    running = true; document.getElementById('overlay').classList.remove('show'); buildGrid();
    player.pos.set(0,1.6, GRID_H/2 + 3); player.vel.set(0,0,0); player.yaw = 0; player.pitch = 0; camera.position.copy(player.pos);
    uncoveredCount = 0; document.getElementById('uncovered').textContent = 0;
    // reset streak on restart (as requested)
    setStreak(0);
    saveState();
  }

  // auto-load on startup if save exists
  if (localStorage.getItem(SAVE_KEY)){
    const ok = loadState();
    if (ok) console.log('Auto-loaded saved progress.');
  }

  // periodic autosave already set earlier; also save on visibility change + beforeunload
  document.addEventListener('visibilitychange', ()=>{ if (document.visibilityState === 'hidden') saveState(); });
  window.addEventListener('beforeunload', ()=>{ saveState(); });

  // expose for debugging
  window.restartMinesweeper = restartGame;
  window._save = saveState;
  window._load = loadState;
  window._clear = clearSave;

  // initial streak UI sync
  streakEl.textContent = streak;

  console.log('Save/load + streak features enabled (localStorage).');
})();
</script>
</body>
</html>
